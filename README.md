# Задание 

Написать апи-сервис на FastAPI с двумя эндпоинтами: для приема и создания сообщений.
```
GET /api/v1/messages
POST /api/v1/message
```

В качестве БД - MongoDB

В качестве веб-сервера - Nginx

Также написать телеграм-бота на aiogram3 c теми же функциями. БД у бота и проекта общая.

## Доп. активности:
Добавить кэширование через redis (сделано)

Развернуть на машине с подключением ssl (машина есть, сертификата нет)

Сделать так, чтобы было понятно, кто отправил сообщение (в боте сделано, на апишке нет)

Сделать пагинацию (сделано)

# Что сделано

Бот написан на aiogram3, кэшил на redis и aioredis, с монгой общался через Motor.

Написал FSM для состояния ввода сообщения. Написана пагинация, реализовано перелистывание страниц на инлайн-клавиатуре.

Апишка написана на fastapi, сначала собирался кэшить через fastapi-cache2, но столкнулся с тем, что кэши были не общими.
Неканон, переписал на прямой redis + aioredis. Маршруты на v1 сделаны на fastapi-versioning. Соответсвенно, чтобы баловаться
надо идти на ```ipaddr:port/api/v1/docs```. Эндпоинты будут там. С монгой разговаривал тоже через мотор. Думал для идетификации пользователей поиграть с куками, но не получилось.

Кэшируются данные постранично, кэш общий, то есть если бот закешил первую страницу сообщений, то апишка сможет перехватить этот кэш и не делать запросы в бд.
И наоборот.
При добавлении сообщения удаляется только последняя страница, если она незаполнена. То есть, в случае когда, резмер страницы 10 сообщений, а
закэшированно 2 сообщения, то эта страница удалится из кэша, сообщение добавится и страница закэшируется при следующем запросе. Кэши остальных страниц не удаляются, тк нет сортировок и группировок,
а значит данные сохраняют свой порядок.

## Как баловаться

Клоним репу, вносим ключ бота на пути ```botapi/bot/.env```, пишем ``` docker compose build``` и ``` docker compose up``` 
При желании, можно поменять порты в compose-файле.

